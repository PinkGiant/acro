<style id="cax">#cx{width: 200px;height: 200px;position: fixed; top: 200px; left: 198px;}
#cxa{transform:rotate3d(3, 1, 1, 230deg);filter:blur(4px)brightness(0);width: 200px;height: 200px;position: fixed;top:286px;left:162px;}</style>
<style id="vcz"></style>
<style>
  #block{ background: url('block.png');width: 99999999px;background-size: 0.03% 168%;height: 55%;}
.stick_out {position: fixed;left: 50px;top:500px;}
.stick_main {position: absolute;left: 32px;top: 30px;transition: 0.2s;transform: translate3d(0px, 0px, 0px);}</style>
</head>
<body translate="no"  style="background:linear-gradient(243deg,#00ffd0,#0089ff);">
<input id="t" style="display: none;"><input id="v" style="display: none;"><input id="b"><input id="a" style="display: none;">
<div id="block" style=" background: url('block.png');width: 100%;position:fixed;top: 357px;left:0; background-size: 151% 100%;height: 55%;"></div>

<img id="cx" src="assets/char/1.png">
<img id="cxa" src="assets/char/1.png">
<input type="button" onclick="openfile();" value="Open" style="position: fixed;top: 0;left: 50px;background: #560040;border: none;font-family:calibri;font-size: 22px;color: white;">
<input type="button" onclick="save();" value="Save" style="position: fixed;top: 0;left: 113px;background: #560040;border: none;font-family:calibri;font-size: 22px;color: white;">

<div class="stick_out" style="width:126px;height:126px;background:rgb(36 36 36 / 39%);border-radius: 10000px;">
  <div id="stick" class="stick_main" style="width: 64px;height: 64px;background: rgb(36,36,36);border-radius: 10000px;">
    </div>
  </div>

<script>window.HUB_EVENTS={ASSET_ADDED:"ASSET_ADDED",ASSET_DELETED:"ASSET_DELETED",ASSET_DESELECTED:"ASSET_DESELECTED",ASSET_SELECTED:"ASSET_SELECTED",ASSET_UPDATED:"ASSET_UPDATED",CONSOLE_CHANGE:"CONSOLE_CHANGE",CONSOLE_CLOSED:"CONSOLE_CLOSED",CONSOLE_EVENT:"CONSOLE_EVENT",CONSOLE_OPENED:"CONSOLE_OPENED",CONSOLE_RUN_COMMAND:"CONSOLE_RUN_COMMAND",CONSOLE_SERVER_CHANGE:"CONSOLE_SERVER_CHANGE",EMBED_ACTIVE_PEN_CHANGE:"EMBED_ACTIVE_PEN_CHANGE",EMBED_ACTIVE_THEME_CHANGE:"EMBED_ACTIVE_THEME_CHANGE",EMBED_ATTRIBUTE_CHANGE:"EMBED_ATTRIBUTE_CHANGE",EMBED_RESHOWN:"EMBED_RESHOWN",FORMAT_FINISH:"FORMAT_FINISH",FORMAT_ERROR:"FORMAT_ERROR",FORMAT_START:"FORMAT_START",IFRAME_PREVIEW_RELOAD_CSS:"IFRAME_PREVIEW_RELOAD_CSS",IFRAME_PREVIEW_URL_CHANGE:"IFRAME_PREVIEW_URL_CHANGE",KEY_PRESS:"KEY_PRESS",LINTER_FINISH:"LINTER_FINISH",LINTER_START:"LINTER_START",PEN_CHANGE_SERVER:"PEN_CHANGE_SERVER",PEN_CHANGE:"PEN_CHANGE",PEN_EDITOR_CLOSE:"PEN_EDITOR_CLOSE",PEN_EDITOR_CODE_FOLD:"PEN_EDITOR_CODE_FOLD",PEN_EDITOR_ERRORS:"PEN_EDITOR_ERRORS",PEN_EDITOR_EXPAND:"PEN_EDITOR_EXPAND",PEN_EDITOR_FOLD_ALL:"PEN_EDITOR_FOLD_ALL",PEN_EDITOR_LOADED:"PEN_EDITOR_LOADED",PEN_EDITOR_REFRESH_REQUEST:"PEN_EDITOR_REFRESH_REQUEST",PEN_EDITOR_RESET_SIZES:"PEN_EDITOR_RESET_SIZES",PEN_EDITOR_SIZES_CHANGE:"PEN_EDITOR_SIZES_CHANGE",PEN_EDITOR_UI_CHANGE_SERVER:"PEN_EDITOR_UI_CHANGE_SERVER",PEN_EDITOR_UI_CHANGE:"PEN_EDITOR_UI_CHANGE",PEN_EDITOR_UI_DISABLE:"PEN_EDITOR_UI_DISABLE",PEN_EDITOR_UI_ENABLE:"PEN_EDITOR_UI_ENABLE",PEN_EDITOR_UNFOLD_ALL:"PEN_EDITOR_UNFOLD_ALL",PEN_ERROR_INFINITE_LOOP:"PEN_ERROR_INFINITE_LOOP",PEN_ERROR_RUNTIME:"PEN_ERROR_RUNTIME",PEN_ERRORS:"PEN_ERRORS",PEN_LIVE_CHANGE:"PEN_LIVE_CHANGE",PEN_LOGS:"PEN_LOGS",PEN_MANIFEST_CHANGE:"PEN_MANIFEST_CHANGE",PEN_MANIFEST_FULL:"PEN_MANIFEST_FULL",PEN_PREVIEW_FINISH:"PEN_PREVIEW_FINISH",PEN_PREVIEW_START:"PEN_PREVIEW_START",PEN_SAVED:"PEN_SAVED",POPUP_CLOSE:"POPUP_CLOSE",POPUP_OPEN:"POPUP_OPEN",POST_CHANGE:"POST_CHANGE",POST_SAVED:"POST_SAVED",PROCESSING_FINISH:"PROCESSING_FINISH",PROCESSING_START:"PROCESSED_STARTED"},"object"!=typeof window.CP&&(window.CP={}),window.CP.PenTimer={programNoLongerBeingMonitored:!1,timeOfFirstCallToShouldStopLoop:0,_loopExits:{},_loopTimers:{},START_MONITORING_AFTER:2e3,STOP_ALL_MONITORING_TIMEOUT:5e3,MAX_TIME_IN_LOOP_WO_EXIT:2200,exitedLoop:function(E){this._loopExits[E]=!0},shouldStopLoop:function(E){if(this.programKilledSoStopMonitoring)return!0;if(this.programNoLongerBeingMonitored)return!1;if(this._loopExits[E])return!1;var _=this._getTime();if(0===this.timeOfFirstCallToShouldStopLoop)return this.timeOfFirstCallToShouldStopLoop=_,!1;var o=_-this.timeOfFirstCallToShouldStopLoop;if(o<this.START_MONITORING_AFTER)return!1;if(o>this.STOP_ALL_MONITORING_TIMEOUT)return this.programNoLongerBeingMonitored=!0,!1;try{this._checkOnInfiniteLoop(E,_)}catch(N){return this._sendErrorMessageToEditor(),this.programKilledSoStopMonitoring=!0,!0}return!1},_sendErrorMessageToEditor:function(){try{if(this._shouldPostMessage()){var E={topic:HUB_EVENTS.PEN_ERROR_INFINITE_LOOP,data:{line:this._findAroundLineNumber()}};parent.postMessage(E,"*")}else this._throwAnErrorToStopPen()}catch(_){this._throwAnErrorToStopPen()}},_shouldPostMessage:function(){return document.location.href.match(/boomboom/)},_throwAnErrorToStopPen:function(){throw"We found an infinite loop in your Pen. We've stopped the Pen from running. More details and workarounds at https://blog.codepen.io/2016/06/08/can-adjust-infinite-loop-protection-timing/"},_findAroundLineNumber:function(){var E=new Error,_=0;if(E.stack){var o=E.stack.match(/boomboom\S+:(\d+):\d+/);o&&(_=o[1])}return _},_checkOnInfiniteLoop:function(E,_){if(!this._loopTimers[E])return this._loopTimers[E]=_,!1;var o;if(_-this._loopTimers[E]>this.MAX_TIME_IN_LOOP_WO_EXIT)throw"Infinite Loop found on loop: "+E},_getTime:function(){return+new Date}},window.CP.shouldStopExecution=function(E){var _=window.CP.PenTimer.shouldStopLoop(E);return!0===_&&console.warn("[CodePen]: An infinite loop (or a loop taking too long) was detected, so we stopped its execution. More details at https://blog.codepen.io/2016/06/08/can-adjust-infinite-loop-protection-timing/"),_},window.CP.exitedLoop=function(E){window.CP.PenTimer.exitedLoop(E)};</script>
<script>
var indexValue = 1;
 function aaa() {indexValue ++;
  document.getElementById("cx").setAttribute('src', "assets/char/"+indexValue+".png");
  document.getElementById("cxa").setAttribute('src', "assets/char/"+indexValue+".png");
if (indexValue > 64){indexValue = 17;}
}

class JoystickController
{
  constructor(stickID, maxDistance, deadzone)
  {
    this.id = stickID;
    let stick = document.getElementById(stickID);

    // location from which drag begins, used to calculate offsets
    this.dragStart = null;

    // track touch identifier in case multiple joysticks present
    this.touchId = null;

    this.active = false;
    this.value = { x: 0, y: 0 };

    let self = this;

    function handleDown(event)
    {
      self.active = true;

      // all drag movements are instantaneous
      stick.style.transition = 'none';

      // touch event fired before mouse event; prevent redundant mouse event from firing
      event.preventDefault();

      if (event.changedTouches)
      self.dragStart = { x: event.changedTouches[0].clientX, y: event.changedTouches[0].clientY };else

      self.dragStart = { x: event.clientX, y: event.clientY };

      // if this is a touch event, keep track of which one
      if (event.changedTouches)
      self.touchId = event.changedTouches[0].identifier;
    }

    function handleMove(event)
    {
      if (!self.active) return;

      // if this is a touch event, make sure it is the right one
      // also handle multiple simultaneous touchmove events
      let touchmoveId = null;
      if (event.changedTouches)
      {
        for (let i = 0; i < event.changedTouches.length; i++)
        {
          if (self.touchId == event.changedTouches[i].identifier)
          {
            touchmoveId = i;
            event.clientX = event.changedTouches[i].clientX;
            event.clientY = event.changedTouches[i].clientY;
          }
        }

        if (touchmoveId == null) return;
      }

      const xDiff = event.clientX - self.dragStart.x;
      const yDiff = event.clientY - self.dragStart.y;
      const angle = Math.atan2(yDiff, xDiff);
      const distance = Math.min(maxDistance, Math.hypot(xDiff, yDiff));
      const xPosition = distance * Math.cos(angle);
      const yPosition = distance * Math.sin(angle);

      // move stick image to new position
      stick.style.transform = `translate3d(${xPosition}px, ${yPosition}px, 0px)`;
      // deadzone adjustment
      const distance2 = distance < deadzone ? 0 : maxDistance / (maxDistance - deadzone) * (distance - deadzone);
      const xPosition2 = distance2 * Math.cos(angle);
      const yPosition2 = distance2 * Math.sin(angle);
      const xPercent = parseFloat((xPosition2 / maxDistance).toFixed(4));
      const yPercent = parseFloat((yPosition2 / maxDistance).toFixed(4));

      self.value = { x: xPercent, y: yPercent };
    }

    function handleUp(event)
    {
      if (!self.active) return;

      // if this is a touch event, make sure it is the right one
      if (event.changedTouches && self.touchId != event.changedTouches[0].identifier) return;

      // transition the joystick position back to center
      stick.style.transition = '500ms';
      stick.style.transform = `translate3d(0px, 0px, 0px)rotatey(360deg)`;

      // reset everything
      self.value = { x: 0, y: 0 };
      self.touchId = null;
      self.active = false;
    }

    stick.addEventListener('mousedown', handleDown);
    stick.addEventListener('touchstart', handleDown);
    document.addEventListener('mousemove', handleMove, { passive: false });
    document.addEventListener('touchmove', handleMove, { passive: false });
    document.addEventListener('mouseup', handleUp);
    document.addEventListener('touchend', handleUp);
  }}

let myStick = new JoystickController("stick", 64, 8);
function update()
{
  var xval = parseInt(myStick.value.x * 500);
  var yval = parseInt(myStick.value.y * -500);
  var rval = yval - xval;
  var lval = yval + xval;
  document.getElementById('t').value = (myStick.value.x *1);
}

function loop()
{
  requestAnimationFrame(loop);
  update();
}
loop();
document.getElementById('a').value = -200;
function jump(){
  setTimeout("document.getElementById('a').value = -10;document.getElementById('vcz').innerHTML = '#cx{transition: 1s;}';",1);
  setTimeout("document.getElementById('a').value = -200;document.getElementById('vcz').innerHTML = '#cx{transition:none;}';",1000);
}
setInterval('abv();',1)
setInterval('abv();',1)
setInterval('abv();',1)
abv();
function abv(){
var lftrt= document.getElementById('t').value;
if(lftrt < 0){document.getElementById('b').value --;document.getElementById('cax').innerHTML = "#cxa{position: fixed;top:286px;left:162px;transform:rotate3d(3, 1, 1, 230deg)rotatey(180deg);filter:blur(4px)brightness(0);width: 200px;height: 200px;}#cx{transform: rotatey(180deg);width: 200px;height: 200px;transition:cubic-bezier(0.42, 0, 0, 2.9);position: fixed; top: 200px; left: 198px;}";aaa();}
if(lftrt > 0){document.getElementById('b').value ++;document.getElementById('cax').innerHTML = "#cxa{position: fixed;top:286px;left:162px;transform:rotate3d(3, 1, 1, 230deg);filter:blur(4px)brightness(0);width: 200px;height: 200px;}#cx{width: 200px;height: 200px;transition:cubic-bezier(0.42, 0, 0, 2.9);position: fixed; top: 200px; left: 198px;}";aaa();}
if(document.getElementById('b').value < -300){document.getElementById('cax').innerHTML = "#cxa{position: fixed;top:6200px;transition:10s;left:162px;transform:rotate3d(3, 1, 1, 230deg);filter:blur(4px)brightness(0);width: 200px;height: 200px;}#cx{width: 200px;height: 200px;transition:10s;position: fixed; top: 6200px; left: 198px;}";}
if(document.getElementById('b').value > 33554116){document.getElementById('cax').innerHTML = "#cxa{position: fixed;top:6200px;transition:10s;left:162px;transform:rotate3d(3, 1, 1, 230deg);filter:blur(4px)brightness(0);width: 200px;height: 200px;}#cx{width: 200px;height: 200px;transition:10s;position: fixed; top: 6200px; left: 198px;}";}
document.getElementById('block').style = "position:fixed;top:357px;left:"+(document.getElementById('b').value / -1)+"px;";
 } 

 let fileHandle;
            async function openfile(){
                [fileHandle] = await window.showOpenFilePicker();
                let fileData = await fileHandle.getFile();
                let text = await fileData.text();
                document.getElementById('b').value = text;
                
            }
                async function save(){
        var a = document.getElementById('b').value;
if (!a){
    alert('Choose a save file to save your game or load your saved game data . Click OK to continue .');
    fileHandle = await window.showSaveFilePicker();sav();}else{sav();}}
         async function sav(){
            alert('Allow to save your game data. Click OK to continue .');
            let stream = await fileHandle.createWritable();
            await stream.write(document.getElementById('b').value);await stream.close();
            alert('Game saved successfully. Click OK to continue .');
        }







 setInterval('abv();',1);
</script>

  

</body>

</html>
 
